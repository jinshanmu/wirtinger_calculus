import Mathlib
import WirtingerCalculus.Basic

/-!
First-order operation rules, star-based (no `Complex.conj`).

What this file provides:
* real-linear conjugation CLM `C‚ÑÇ : ‚ÑÇ ‚ÜíL[‚Ñù] ‚ÑÇ` defined via `star`
* `J` anti-commutes with `C‚ÑÇ`
* conjugation rules for `D‚Çä`, `D‚Çã` (both operator & directional forms)
* product / reciprocal / quotient rules (directional & gradient forms)
* formal partials on `‚ÑÇ` (`dz`, `dzbar`) and a 1D identity for `fderivR`
* directional chain rules for post-composition with a scalar map `g : ‚ÑÇ ‚Üí ‚ÑÇ`

Only APIs used from your `Basic.lean`:
`Jc_apply`, `Jc_comp_Jc`, `R_split_point`, `Dplus_comm_J_point`,
`Dminus_anticomm_J_point`, `inner_gradPlus_eq_Dplus`,
`Dminus_eq_inner_gradMinus`, `fderivR_apply_split_grad`.
-/

noncomputable section
open Complex Topology
open scoped ComplexInnerProductSpace

namespace Wirtinger

-- Notation shorthands used throughout
local notation "D‚Çä" => DplusCLM
local notation "D‚Çã" => DminusCLM
local notation "‚àá‚Çä" => gradPlus
local notation "‚àá‚Çã" => gradMinus

/-! ## Conjugation over `‚ÑÇ` as a real-linear CLM, via `star` -/

-- Keep `Complex.star_def` private to simp so we can expand it only when needed.
attribute [-simp] Complex.star_def

/-- Real-linear complex conjugation on `‚ÑÇ`, implemented by `star`. -/
@[simp] def C‚ÑÇ : ‚ÑÇ ‚ÜíL[‚Ñù] ‚ÑÇ :=
{ toLinearMap :=
  { toFun := fun z => star z
  , map_add' := by intro z w; simp
  , map_smul' := by
      intro r z
      -- star ((r : ‚ÑÇ) * z) = star z * (r : ‚ÑÇ)
      change star ((r : ‚ÑÇ) * z) = (r : ‚ÑÇ) * star z
      have : star ((r : ‚ÑÇ) * z) = star z * (r : ‚ÑÇ) := by
        -- `star` reverses multiplication; `star (r:‚ÑÇ) = r`
        simp [star_mul, Complex.star_def]
      simpa [mul_comm] using this }
, cont := continuous_star }

@[simp] lemma C‚ÑÇ_apply (z : ‚ÑÇ) : C‚ÑÇ z = star z := rfl

/-- `J` anti-commutes with conjugation on `‚ÑÇ`. -/
lemma Jc_comp_C‚ÑÇ_anticom :
  (Jc ‚ÑÇ).comp C‚ÑÇ = - (C‚ÑÇ.comp (Jc ‚ÑÇ)) := by
  ext z
  -- Goal: I * star z = - star (I * z)
  -- Turn the RHS into `star z * I` and finish by commutativity
  have : - star (I * z) = star z * I := by
    simp [star_mul, Complex.star_def, mul_comm]
  simpa [this, mul_comm, Jc_apply, C‚ÑÇ_apply]

/-- Compatibility of the anti-twist with conjugation. -/
lemma A‚Ñí_comp_C‚ÑÇ
  {H : Type*} [NormedAddCommGroup H] [NormedSpace ‚ÑÇ H]
  (T : H ‚ÜíL[‚Ñù] ‚ÑÇ) :
  A‚Ñí (H:=H) (W:=‚ÑÇ) (C‚ÑÇ.comp T) = - C‚ÑÇ.comp (A‚Ñí (H:=H) (W:=‚ÑÇ) T) := by
  -- Use `A‚Ñí_apply : A‚Ñí T v = I * T (I ‚Ä¢ v)` and expand `star`.
  ext v
  simp [A‚Ñí_apply, Jc_apply, C‚ÑÇ_apply, star_mul, Complex.star_def, mul_comm]

/-! ## Scalar-valued rules on a complex Hilbert space -/

section scalar_rules
variable {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ‚ÑÇ H]

/-! ### Conjugation (via `star`) -/

/-- Operator form: `D‚Çä(star ‚àò f) = C‚ÑÇ ‚àòL D‚Çã f`. -/
lemma Dplus_star_op (f : H ‚Üí ‚ÑÇ) (u : H)
    (hf : DifferentiableAt ‚Ñù f u) :
    D‚Çä (fun x => star (f x)) u = C‚ÑÇ.comp (D‚Çã f u) := by
  classical
  let D := fderivR f u
  have hDf : fderivR (fun x => star (f x)) u = C‚ÑÇ.comp D :=
    (C‚ÑÇ.hasFDerivAt.comp u hf.hasFDerivAt).fderiv
  -- Unfold `D‚Çä` via your definition and use `A‚Ñí_comp_C‚ÑÇ`.
  simp [DplusCLM, hDf, A‚Ñí_comp_C‚ÑÇ, ContinuousLinearMap.comp_sub,
        ContinuousLinearMap.comp_add, sub_eq_add_neg]

/-- Operator form: `D‚Çã(star ‚àò f) = C‚ÑÇ ‚àòL D‚Çä f`. -/
lemma Dminus_star_op (f : H ‚Üí ‚ÑÇ) (u : H)
    (hf : DifferentiableAt ‚Ñù f u) :
    D‚Çã (fun x => star (f x)) u = C‚ÑÇ.comp (D‚Çä f u) := by
  classical
  let D := fderivR f u
  have hDf : fderivR (fun x => star (f x)) u = C‚ÑÇ.comp D :=
    (C‚ÑÇ.hasFDerivAt.comp u hf.hasFDerivAt).fderiv
  simp [DminusCLM, hDf, A‚Ñí_comp_C‚ÑÇ, ContinuousLinearMap.comp_sub,
        ContinuousLinearMap.comp_add, sub_eq_add_neg, add_comm]

/-- Directional forms. -/
@[simp] lemma Dplus_star_dir (f : H ‚Üí ‚ÑÇ) (u v : H) (hf : DifferentiableAt ‚Ñù f u) :
  D‚Çä (fun x => star (f x)) u v = star (D‚Çã f u v) := by
  simpa using congrArg (fun L => L v) (Dplus_star_op f u hf)

@[simp] lemma Dminus_star_dir (f : H ‚Üí ‚ÑÇ) (u v : H) (hf : DifferentiableAt ‚Ñù f u) :
  D‚Çã (fun x => star (f x)) u v = star (D‚Çä f u v) := by
  simpa using congrArg (fun L => L v) (Dminus_star_op f u hf)

/-! ### Product / reciprocal / quotient -/

section product_like
variable [CompleteSpace H]

/-- **Directional product rule** for `D‚Çä`. -/
lemma Dplus_prod_dir (f g : H ‚Üí ‚ÑÇ) (u v : H)
    (hf : DifferentiableAt ‚Ñù f u) (hg : DifferentiableAt ‚Ñù g u) :
  D‚Çä (fun x => f x * g x) u v
    = D‚Çä f u v * g u + f u * D‚Çä g u v := by
  classical
  let Df := fderivR f u
  let Dg := fderivR g u
  let Dfg := fderivR (fun x => f x * g x) u
  have h_fderiv_eq : Dfg = f u ‚Ä¢ Dg + g u ‚Ä¢ Df := fderiv_mul hf hg
  have h_Dfg_v : Dfg v = f u * Dg v + g u * Df v := by
    simpa [ContinuousLinearMap.add_apply, ContinuousLinearMap.smul_apply, smul_eq_mul]
      using congrArg (fun L => L v) h_fderiv_eq
  have h_A‚Ñí_fg_v :
      A‚Ñí (H:=H) (W:=‚ÑÇ) Dfg v
        = f u * A‚Ñí (H:=H) (W:=‚ÑÇ) Dg v + g u * A‚Ñí (H:=H) (W:=‚ÑÇ) Df v := by
    -- `A‚Ñí D v = I * D (I ‚Ä¢ v)` in the scalar codomain
    simp [A‚Ñí_apply, h_Dfg_v, mul_add, mul_assoc]
  -- Unfold `D‚Çä` and substitute the two pointwise identities
  simp [DplusCLM, h_Dfg_v, h_A‚Ñí_fg_v, add_comm, add_left_comm, add_assoc,
        mul_comm, mul_left_comm, mul_assoc]

/-- **Directional product rule** for `D‚Çã`. -/
lemma Dminus_prod_dir (f g : H ‚Üí ‚ÑÇ) (u v : H)
    (hf : DifferentiableAt ‚Ñù f u) (hg : DifferentiableAt ‚Ñù g u) :
  D‚Çã (fun x => f x * g x) u v
    = D‚Çã f u v * g u + f u * D‚Çã g u v := by
  classical
  let Df := fderivR f u
  let Dg := fderivR g u
  let Dfg := fderivR (fun x => f x * g x) u
  have h_fderiv_eq : Dfg = f u ‚Ä¢ Dg + g u ‚Ä¢ Df := fderiv_mul hf hg
  have h_Dfg_v : Dfg v = f u * Dg v + g u * Df v := by
    simpa [ContinuousLinearMap.add_apply, ContinuousLinearMap.smul_apply, smul_eq_mul]
      using congrArg (fun L => L v) h_fderiv_eq
  have h_A‚Ñí_fg_v :
      A‚Ñí (H:=H) (W:=‚ÑÇ) Dfg v
        = f u * A‚Ñí (H:=H) (W:=‚ÑÇ) Dg v + g u * A‚Ñí (H:=H) (W:=‚ÑÇ) Df v := by
    simp [A‚Ñí_apply, h_Dfg_v, mul_add, mul_assoc]
  simp [DminusCLM, h_Dfg_v, h_A‚Ñí_fg_v, add_comm, add_left_comm, add_assoc,
        mul_comm, mul_left_comm, mul_assoc]

/-- **Gradient product rule.** -/
lemma grad_prod (f g : H ‚Üí ‚ÑÇ) (u : H)
    (hf : DifferentiableAt ‚Ñù f u) (hg : DifferentiableAt ‚Ñù g u) :
  ‚àá‚Çä (fun x => f x * g x) u
    = star (g u) ‚Ä¢ ‚àá‚Çä f u + star (f u) ‚Ä¢ ‚àá‚Çä g u
‚àß ‚àá‚Çã (fun x => f x * g x) u
    = g u ‚Ä¢ ‚àá‚Çã f u + f u ‚Ä¢ ‚àá‚Çã g u := by
  constructor
  ¬∑
    -- compare via Riesz
    apply (InnerProductSpace.toDual ‚ÑÇ H).injective
    ext v
    simp [inner_gradPlus_eq_Dplus, Dplus_prod_dir f g u v hf hg,
          inner_add_left, inner_smul_left, mul_comm, mul_left_comm, mul_assoc]
  ¬∑
    apply (InnerProductSpace.toDual ‚ÑÇ H).injective
    ext v
    simp [Dminus_eq_inner_gradMinus, Dminus_prod_dir f g u v hf hg,
          inner_add_right, inner_smul_right, mul_comm, mul_left_comm, mul_assoc]

end product_like

/-!  Congruence under `=·∂†[ùìù u]`. -/
section congr_helpers

private lemma fderivR_congr_of_eventuallyEq
  {H : Type*} [NormedAddCommGroup H] [NormedSpace ‚ÑÇ H]
  (f g : H ‚Üí ‚ÑÇ) (u : H)
  (hf : DifferentiableAt ‚Ñù f u) (hg : DifferentiableAt ‚Ñù g u)
  (h : f =·∂†[ùìù u] g) :
  fderivR f u = fderivR g u := by
  -- Uniqueness of the Fr√©chet derivative
  have hf' := hf.hasFDerivAt
  have hg' := hg.hasFDerivAt
  have : HasFDerivAt g (fderivR f u) u := hf'.congr (by simpa using h.symm)
  exact (hg'.unique this)

lemma DplusCLM_congr_of_eventuallyEq {H : Type*}
  [NormedAddCommGroup H] [InnerProductSpace ‚ÑÇ H]
  {f g : H ‚Üí ‚ÑÇ} {u : H}
  (hf : DifferentiableAt ‚Ñù f u) (hg : DifferentiableAt ‚Ñù g u)
  (h : f =·∂†[ùìù u] g) :
  D‚Çä f u = D‚Çä g u := by
  have := fderivR_congr_of_eventuallyEq (H:=H) f g u hf hg h
  simp [DplusCLM, this]

lemma DminusCLM_congr_of_eventuallyEq {H : Type*}
  [NormedAddCommGroup H] [InnerProductSpace ‚ÑÇ H]
  {f g : H ‚Üí ‚ÑÇ} {u : H}
  (hf : DifferentiableAt ‚Ñù f u) (hg : DifferentiableAt ‚Ñù g u)
  (h : f =·∂†[ùìù u] g) :
  D‚Çã f u = D‚Çã g u := by
  have := fderivR_congr_of_eventuallyEq (H:=H) f g u hf hg h
  simp [DminusCLM, this]

lemma gradPlus_congr_of_eventuallyEq {H : Type*}
  [NormedAddCommGroup H] [InnerProductSpace ‚ÑÇ H]
  {f g : H ‚Üí ‚ÑÇ} {u : H}
  (hf : DifferentiableAt ‚Ñù f u) (hg : DifferentiableAt ‚Ñù g u)
  (h : f =·∂†[ùìù u] g) :
  ‚àá‚Çä f u = ‚àá‚Çä g u := by
  have hD := DplusCLM_congr_of_eventuallyEq (H:=H) hf hg h
  apply (InnerProductSpace.toDual ‚ÑÇ H).injective
  ext v; simp [riesz_plus_point, hD]

lemma gradMinus_congr_of_eventuallyEq {H : Type*}
  [NormedAddCommGroup H] [InnerProductSpace ‚ÑÇ H]
  {f g : H ‚Üí ‚ÑÇ} {u : H}
  (hf : DifferentiableAt ‚Ñù f u) (hg : DifferentiableAt ‚Ñù g u)
  (h : f =·∂†[ùìù u] g) :
  ‚àá‚Çã f u = ‚àá‚Çã g u := by
  have hD := DminusCLM_congr_of_eventuallyEq (H:=H) hf hg h
  apply (InnerProductSpace.toDual ‚ÑÇ H).injective
  ext v; simp [riesz_minus_point, hD]

end congr_helpers

/-! ## Formal Wirtinger partials on `‚ÑÇ` -/

section partials_on_C
variable [CompleteSpace ‚ÑÇ]

/-- `dz f z := D‚Çä f z 1`. -/
def dz (f : ‚ÑÇ ‚Üí ‚ÑÇ) (z : ‚ÑÇ) : ‚ÑÇ := D‚Çä f z (1 : ‚ÑÇ)

/-- `dzbar f z := D‚Çã f z 1`. -/
def dzbar (f : ‚ÑÇ ‚Üí ‚ÑÇ) (z : ‚ÑÇ) : ‚ÑÇ := D‚Çã f z (1 : ‚ÑÇ)

/-- 1D identity on `‚ÑÇ`:
`fderivR f u w = (dz f u) * w + (dzbar f u) * star w`. -/
lemma fderiv_via_partials (f : ‚ÑÇ ‚Üí ‚ÑÇ) (u w : ‚ÑÇ) :
  fderivR f u w = dz f u * w + dzbar f u * star w := by
  -- Split via your scalar identity
  have hsplit := fderivR_apply_split_grad (H:=‚ÑÇ) (f:=f) (u:=u) (v:=w)
  -- First term: ‚ü™‚àá‚Çä, w‚ü´ = D‚Çä f u w = ((‚ÑÇ-linear lift) at 1) * w
  have hplus :
      D‚Çä (H:=‚ÑÇ) (W:=‚ÑÇ) f u w = (D‚Çä (H:=‚ÑÇ) (W:=‚ÑÇ) f u (1 : ‚ÑÇ)) * w := by
    -- use that `D‚Çä` is the underlying map of an ‚ÑÇ-linear map
    have : (DplusCLM_c_linear (H:=‚ÑÇ) f u) w
            = w * (DplusCLM_c_linear (H:=‚ÑÇ) f u) 1 := by
      -- ‚ÑÇ-linear maps ‚ÑÇ‚Üí‚ÑÇ are scalar multiplications by their value at 1
      simpa [Algebra.smul_def, mul_comm] using
        (DplusCLM_c_linear (H:=‚ÑÇ) f u).map_smul w (1:‚ÑÇ)
    simpa [DplusCLM_c_linear_apply, dz] using this
  -- Second term: D‚Çã f u w = dzbar * star w (via the ‚ÑÇ-linear map `w ‚Ü¶ star (D‚Çã w)`)
  have hminus :
      D‚Çã (H:=‚ÑÇ) (W:=‚ÑÇ) f u w = dzbar f u * star w := by
    -- define G(w) = star (D‚Çã f u w), which is ‚ÑÇ-linear
    have : (DminusCLM_star_c_linear (H:=‚ÑÇ) f u) w
            = w * (DminusCLM_star_c_linear (H:=‚ÑÇ) f u) 1 := by
      simpa [Algebra.smul_def, mul_comm] using
        (DminusCLM_star_c_linear (H:=‚ÑÇ) f u).map_smul w (1:‚ÑÇ)
    -- Now take `star` on both sides
    -- LHS is `star (D‚Çã f u w)`; RHS is `star (w * star (D‚Çã f u 1)) = star w * D‚Çã f u 1`
    -- which equals `dzbar f u * star w`
    have := congrArg star (by
      simpa [DminusCLM_star_c_linear_apply] using this)
    -- `star (w * star a) = star (star a) * star w = a * star w`
    -- commute to match target
    simpa [dzbar, star_mul, star_star, mul_comm, mul_left_comm, mul_assoc] using this
  -- Put both together
  simpa [inner_gradPlus_eq_Dplus, Dminus_eq_inner_gradMinus, hplus, hminus]

end partials_on_C

/-! ## Quotient / inverse via gradients -/

section product_like
variable [CompleteSpace H]

/-- **Reciprocal rule** (pointwise nonvanishing). -/
lemma grad_inv (g : H ‚Üí ‚ÑÇ) (u : H)
    (hg : DifferentiableAt ‚Ñù g u) (hgu : g u ‚â† 0) :
  ‚àá‚Çä (fun x => (g x)‚Åª¬π) u = - ((star (g u)) ^ 2)‚Åª¬π ‚Ä¢ ‚àá‚Çä g u
‚àß ‚àá‚Çã (fun x => (g x)‚Åª¬π) u = - ((g u) ^ 2)‚Åª¬π ‚Ä¢ ‚àá‚Çã g u := by
  have hg_inv : DifferentiableAt ‚Ñù (fun x => (g x)‚Åª¬π) u := hg.inv hgu
  -- product rule for g * g^{-1}
  have hprod := grad_prod g (fun x => (g x)‚Åª¬π) u hg hg_inv
  -- `g * g^{-1} = 1` on a punctured neighborhood of `u`
  have h_eventually_one :
    (fun x => g x * (g x)‚Åª¬π) =·∂†[ùìù u] (fun _ => (1 : ‚ÑÇ)) := by
    filter_upwards [hg.continuousAt.eventually_ne hgu] with x hx
    simpa [hx] using (mul_inv_cancel hx)
  -- gradients of a constant are zero; use congruence
  have h_const_plus : ‚àá‚Çä (fun _ : H => (1 : ‚ÑÇ)) u = 0 := by
    apply (InnerProductSpace.toDual ‚ÑÇ H).injective; ext v
    simp [inner_gradPlus_eq_Dplus, DplusCLM, fderiv_const]
  have h_const_minus : ‚àá‚Çã (fun _ : H => (1 : ‚ÑÇ)) u = 0 := by
    apply (InnerProductSpace.toDual ‚ÑÇ H).injective; ext v
    simp [Dminus_eq_inner_gradMinus, DminusCLM, fderiv_const]
  have h_left_plus :
      ‚àá‚Çä (fun x => g x * (g x)‚Åª¬π) u = 0 := by
    simpa [h_const_plus]
      using gradPlus_congr_of_eventuallyEq (H:=H)
            (hf := (hg.mul hg_inv))
            (hg := differentiableAt_const) h_eventually_one
  have h_left_minus :
      ‚àá‚Çã (fun x => g x * (g x)‚Åª¬π) u = 0 := by
    simpa [h_const_minus]
      using gradMinus_congr_of_eventuallyEq (H:=H)
            (hf := (hg.mul hg_inv))
            (hg := differentiableAt_const) h_eventually_one
  constructor
  ¬∑
    -- 0 = star((g u)‚Åª¬π) ‚Ä¢ ‚àá‚Çä g u + star(g u) ‚Ä¢ ‚àá‚Çä (g‚Åª¬π) u
    have : 0 = star ((g u)‚Åª¬π) ‚Ä¢ ‚àá‚Çä g u + star (g u) ‚Ä¢ ‚àá‚Çä (fun x => (g x)‚Åª¬π) u := by
      simpa [h_left_plus] using hprod.1
    -- isolate the unknown and divide by `star (g u)`
    have hsolve :
        star (g u) ‚Ä¢ ‚àá‚Çä (fun x => (g x)‚Åª¬π) u
          = - star ((g u)‚Åª¬π) ‚Ä¢ ‚àá‚Çä g u := by
      simpa [add_comm, add_left_comm, add_assoc, smul_add, smul_neg] using this
    have hne : star (g u) ‚â† 0 := star_ne_zero.mpr hgu
    have := congrArg (fun x => (star (g u))‚Åª¬π ‚Ä¢ x) hsolve
    -- simplify coefficients
    simpa [smul_smul, inv_mul_cancel hne, one_smul,
           star_inv, pow_two, mul_comm, mul_left_comm, mul_assoc]
      using this
  ¬∑
    -- 0 = (g u) ‚Ä¢ ‚àá‚Çã g u + g u ‚Ä¢ ‚àá‚Çã (g‚Åª¬π) u
    have : 0 = (g u) ‚Ä¢ ‚àá‚Çã g u + g u ‚Ä¢ ‚àá‚Çã (fun x => (g x)‚Åª¬π) u := by
      simpa [h_left_minus] using hprod.2
    have hsolve :
        g u ‚Ä¢ ‚àá‚Çã (fun x => (g x)‚Åª¬π) u
          = - (g u)‚Åª¬π ‚Ä¢ ‚àá‚Çã g u := by
      -- rewrite second coefficient with `inv` pulled out later
      simpa [add_comm, add_left_comm, add_assoc, smul_add, smul_neg]
        using this
    have hne : g u ‚â† 0 := hgu
    have := congrArg (fun x => (g u)‚Åª¬π ‚Ä¢ x) hsolve
    simpa [smul_smul, inv_mul_cancel hne, one_smul, pow_two]
      using this

/-- **Quotient rule** (pointwise nonvanishing). -/
lemma grad_quot (f g : H ‚Üí ‚ÑÇ) (u : H)
    (hf : DifferentiableAt ‚Ñù f u) (hg : DifferentiableAt ‚Ñù g u) (hgu : g u ‚â† 0) :
  ‚àá‚Çä (fun x => f x / g x) u
    = ((star (g u)) ^ 2)‚Åª¬π ‚Ä¢ (star (g u) ‚Ä¢ ‚àá‚Çä f u - star (f u) ‚Ä¢ ‚àá‚Çä g u)
‚àß ‚àá‚Çã (fun x => f x / g x) u
    = ((g u) ^ 2)‚Åª¬π ‚Ä¢ (g u ‚Ä¢ ‚àá‚Çã f u - f u ‚Ä¢ ‚àá‚Çã g u) := by
  have hg_inv : DifferentiableAt ‚Ñù (fun x => (g x)‚Åª¬π) u := hg.inv hgu
  have hinv := grad_inv (H:=H) g u hg hgu
  constructor
  ¬∑
    -- plus side
    have := (grad_prod f (fun x => (g x)‚Åª¬π) u hf hg_inv).1
    -- substitute ‚àá‚Çä of inverse from `hinv.1`
    -- and regroup scalars
    simpa [div_eq_mul_inv, smul_sub, smul_smul, star_inv, pow_two]
      using this.trans (by
        simp [hinv.1, mul_comm, mul_left_comm, mul_assoc])
  ¬∑
    -- minus side
    have := (grad_prod f (fun x => (g x)‚Åª¬π) u hf hg_inv).2
    simpa [div_eq_mul_inv, smul_sub, smul_smul, pow_two]
      using this.trans (by
        simp [hinv.2, mul_comm, mul_left_comm, mul_assoc])

end product_like

/-! ## Chain rules (directional) for post-composition by `g : ‚ÑÇ ‚Üí ‚ÑÇ` -/

section chain_rules
variable [CompleteSpace H]

/-- Directional chain rule for `D‚Çä` when postcomposing with `g : ‚ÑÇ ‚Üí ‚ÑÇ`. -/
lemma Dplus_comp_scalar_dir
  (f : H ‚Üí ‚ÑÇ) (g : ‚ÑÇ ‚Üí ‚ÑÇ) (u : H) (v : H)
  (hf : DifferentiableAt ‚Ñù f u) (hg : DifferentiableAt ‚Ñù g (f u)) :
  D‚Çä (fun x => g (f x)) u v
    = dz g (f u) * D‚Çä f u v + dzbar g (f u) * star (D‚Çã f u v) := by
  classical
  let Df := fderivR f u
  let Dg := fderivR g (f u)
  have h_chain : fderivR (g ‚àò f) u = Dg.comp Df :=
    (hg.hasFDerivAt.comp u hf.hasFDerivAt).fderiv
  -- 1D expansion of `Dg`
  have h_Dg (w : ‚ÑÇ) : Dg w = dz g (f u) * w + dzbar g (f u) * star w :=
    fderiv_via_partials g (f u) w
  -- Decompose `Df` at `v` and `I‚Ä¢v`
  have h_Df_v : Df v = D‚Çä f u v + D‚Çã f u v := (R_split_point (H:=H) (W:=‚ÑÇ) f u v)
  have h_Df_Iv :
      Df (I ‚Ä¢ v) = I * D‚Çä f u v - I * D‚Çã f u v := by
    -- split at `I‚Ä¢v`, then commute/anticommute with `J`
    have := (R_split_point (H:=H) (W:=‚ÑÇ) f u (I ‚Ä¢ v))
    -- `D‚Çä (I‚Ä¢v) = I * D‚Çä v`,  `D‚Çã (I‚Ä¢v) = - I * D‚Çã v`
    simpa [Dplus_comm_J_point, Dminus_anticomm_J_point, Jc_apply, smul_eq_mul] using this
  -- Compute `D‚Çä (g ‚àò f)` from the definition
  simp [DplusCLM, h_chain, ContinuousLinearMap.comp_apply, h_Dg,
        h_Df_v, h_Df_Iv, star_add, star_sub, star_smul, Complex.star_def, mul_comm, mul_left_comm,
        mul_assoc]

/-- Directional chain rule for `D‚Çã` when postcomposing with `g : ‚ÑÇ ‚Üí ‚ÑÇ`. -/
lemma Dminus_comp_scalar_dir
  (f : H ‚Üí ‚ÑÇ) (g : ‚ÑÇ ‚Üí ‚ÑÇ) (u : H) (v : H)
  (hf : DifferentiableAt ‚Ñù f u) (hg : DifferentiableAt ‚Ñù g (f u)) :
  D‚Çã (fun x => g (f x)) u v
    = dzbar g (f u) * star (D‚Çä f u v) + dz g (f u) * D‚Çã f u v := by
  classical
  let Df := fderivR f u
  let Dg := fderivR g (f u)
  have h_chain : fderivR (g ‚àò f) u = Dg.comp Df :=
    (hg.hasFDerivAt.comp u hf.hasFDerivAt).fderiv
  have h_Dg (w : ‚ÑÇ) : Dg w = dz g (f u) * w + dzbar g (f u) * star w :=
    fderiv_via_partials g (f u) w
  have h_Df_v : Df v = D‚Çä f u v + D‚Çã f u v := (R_split_point (H:=H) (W:=‚ÑÇ) f u v)
  have h_Df_Iv :
      Df (I ‚Ä¢ v) = I * D‚Çä f u v - I * D‚Çã f u v := by
    have := (R_split_point (H:=H) (W:=‚ÑÇ) f u (I ‚Ä¢ v))
    simpa [Dplus_comm_J_point, Dminus_anticomm_J_point, Jc_apply, smul_eq_mul] using this
  simp [DminusCLM, h_chain, ContinuousLinearMap.comp_apply, h_Dg,
        h_Df_v, h_Df_Iv, star_add, star_sub, star_smul, Complex.star_def, mul_comm, mul_left_comm,
        mul_assoc]

end chain_rules

end scalar_rules
end Wirtinger
